//----------------------
// <auto-generated>
//     Generated using the NSwag toolchain v14.0.7.0 (NJsonSchema v11.0.0.0 (Newtonsoft.Json v13.0.0.0)) (http://NSwag.org)
// </auto-generated>
//----------------------

/* tslint:disable */
/* eslint-disable */
// ReSharper disable InconsistentNaming

export class ApiClientBase {
    constructor() { }

    protected async transformOptions(options: RequestInit): Promise<RequestInit> {
        return Promise.resolve(options);
    }
}

export class ApiClient extends ApiClientBase {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        super();
        this.http = http ? http : window as any;
        this.baseUrl = baseUrl ?? "";
    }

    game_CreateNewGame(dto: CreateGameDto): Promise<GameDto> {
        let url_ = this.baseUrl + "/api/games";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(dto);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processGame_CreateNewGame(_response);
        });
    }

    protected processGame_CreateNewGame(response: Response): Promise<GameDto> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 201) {
            return response.text().then((_responseText) => {
            let result201: any = null;
            let resultData201 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result201 = GameDto.fromJS(resultData201);
            return result201;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ValidationProblemDetails.fromJS(resultData400);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = ProblemDetails.fromJS(resultData500);
            return throwException("A server side error occurred.", status, _responseText, _headers, result500);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<GameDto>(null as any);
    }

    game_GetAllJoinableGames(): Promise<GameDto[]> {
        let url_ = this.baseUrl + "/api/games";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processGame_GetAllJoinableGames(_response);
        });
    }

    protected processGame_GetAllJoinableGames(response: Response): Promise<GameDto[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(GameDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return result200;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ValidationProblemDetails.fromJS(resultData400);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("A server side error occurred.", status, _responseText, _headers, result404);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = ProblemDetails.fromJS(resultData500);
            return throwException("A server side error occurred.", status, _responseText, _headers, result500);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<GameDto[]>(null as any);
    }

    game_UpdateGame(dto: UpdateGameDto): Promise<void> {
        let url_ = this.baseUrl + "/api/games";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(dto);

        let options_: RequestInit = {
            body: content_,
            method: "PUT",
            headers: {
                "Content-Type": "application/json",
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processGame_UpdateGame(_response);
        });
    }

    protected processGame_UpdateGame(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 204) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ValidationProblemDetails.fromJS(resultData400);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("A server side error occurred.", status, _responseText, _headers, result404);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = ProblemDetails.fromJS(resultData500);
            return throwException("A server side error occurred.", status, _responseText, _headers, result500);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    game_GetMyGames(userId: string): Promise<GameDto[]> {
        let url_ = this.baseUrl + "/api/games/user/{userId}/my-games";
        if (userId === undefined || userId === null)
            throw new Error("The parameter 'userId' must be defined.");
        url_ = url_.replace("{userId}", encodeURIComponent("" + userId));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processGame_GetMyGames(_response);
        });
    }

    protected processGame_GetMyGames(response: Response): Promise<GameDto[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(GameDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return result200;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ValidationProblemDetails.fromJS(resultData400);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("A server side error occurred.", status, _responseText, _headers, result404);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = ProblemDetails.fromJS(resultData500);
            return throwException("A server side error occurred.", status, _responseText, _headers, result500);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<GameDto[]>(null as any);
    }

    game_GetGameById(id: string): Promise<GameDto> {
        let url_ = this.baseUrl + "/api/games/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processGame_GetGameById(_response);
        });
    }

    protected processGame_GetGameById(response: Response): Promise<GameDto> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GameDto.fromJS(resultData200);
            return result200;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ValidationProblemDetails.fromJS(resultData400);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("A server side error occurred.", status, _responseText, _headers, result404);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = ProblemDetails.fromJS(resultData500);
            return throwException("A server side error occurred.", status, _responseText, _headers, result500);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<GameDto>(null as any);
    }

    game_GetAllUsers(): Promise<UserDto[]> {
        let url_ = this.baseUrl + "/api/games/users";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processGame_GetAllUsers(_response);
        });
    }

    protected processGame_GetAllUsers(response: Response): Promise<UserDto[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(UserDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return result200;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ValidationProblemDetails.fromJS(resultData400);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("A server side error occurred.", status, _responseText, _headers, result404);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = ProblemDetails.fromJS(resultData500);
            return throwException("A server side error occurred.", status, _responseText, _headers, result500);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<UserDto[]>(null as any);
    }

    game_UpdatePlayer(dto: UpdatePlayerDto): Promise<void> {
        let url_ = this.baseUrl + "/api/games/player";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(dto);

        let options_: RequestInit = {
            body: content_,
            method: "PUT",
            headers: {
                "Content-Type": "application/json",
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processGame_UpdatePlayer(_response);
        });
    }

    protected processGame_UpdatePlayer(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 204) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ValidationProblemDetails.fromJS(resultData400);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("A server side error occurred.", status, _responseText, _headers, result404);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = ProblemDetails.fromJS(resultData500);
            return throwException("A server side error occurred.", status, _responseText, _headers, result500);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    game_RecordGameTurn(gameId: string, dto: TurnDto): Promise<void> {
        let url_ = this.baseUrl + "/api/games/{gameId}";
        if (gameId === undefined || gameId === null)
            throw new Error("The parameter 'gameId' must be defined.");
        url_ = url_.replace("{gameId}", encodeURIComponent("" + gameId));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(dto);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processGame_RecordGameTurn(_response);
        });
    }

    protected processGame_RecordGameTurn(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 204) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ValidationProblemDetails.fromJS(resultData400);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = ProblemDetails.fromJS(resultData500);
            return throwException("A server side error occurred.", status, _responseText, _headers, result500);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }
}

export class BaseDtoOfGuid implements IBaseDtoOfGuid {
    id!: string;

    constructor(data?: IBaseDtoOfGuid) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): BaseDtoOfGuid {
        data = typeof data === 'object' ? data : {};
        let result = new BaseDtoOfGuid();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        return data;
    }
}

export interface IBaseDtoOfGuid {
    id: string;
}

export class GameDto extends BaseDtoOfGuid implements IGameDto {
    gameName!: string;
    gameStatus!: GameStatus;
    startingPlayerId!: string;
    passTile!: TileDto;
    firstRoundTiles!: TileDto[];
    secondRoundTiles!: TileDto[];
    thirdRoundTiles!: TileDto[];
    fourthRoundTiles!: TileDto[];
    fifthRoundTiles!: TileDto[];
    sixthRoundTiles!: TileDto[];
    players!: PlayerDto[];
    turns!: TurnDto[];

    constructor(data?: IGameDto) {
        super(data);
        if (!data) {
            this.passTile = new TileDto();
            this.firstRoundTiles = [];
            this.secondRoundTiles = [];
            this.thirdRoundTiles = [];
            this.fourthRoundTiles = [];
            this.fifthRoundTiles = [];
            this.sixthRoundTiles = [];
            this.players = [];
            this.turns = [];
        }
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.gameName = _data["gameName"];
            this.gameStatus = _data["gameStatus"];
            this.startingPlayerId = _data["startingPlayerId"];
            this.passTile = _data["passTile"] ? TileDto.fromJS(_data["passTile"]) : new TileDto();
            if (Array.isArray(_data["firstRoundTiles"])) {
                this.firstRoundTiles = [] as any;
                for (let item of _data["firstRoundTiles"])
                    this.firstRoundTiles!.push(TileDto.fromJS(item));
            }
            if (Array.isArray(_data["secondRoundTiles"])) {
                this.secondRoundTiles = [] as any;
                for (let item of _data["secondRoundTiles"])
                    this.secondRoundTiles!.push(TileDto.fromJS(item));
            }
            if (Array.isArray(_data["thirdRoundTiles"])) {
                this.thirdRoundTiles = [] as any;
                for (let item of _data["thirdRoundTiles"])
                    this.thirdRoundTiles!.push(TileDto.fromJS(item));
            }
            if (Array.isArray(_data["fourthRoundTiles"])) {
                this.fourthRoundTiles = [] as any;
                for (let item of _data["fourthRoundTiles"])
                    this.fourthRoundTiles!.push(TileDto.fromJS(item));
            }
            if (Array.isArray(_data["fifthRoundTiles"])) {
                this.fifthRoundTiles = [] as any;
                for (let item of _data["fifthRoundTiles"])
                    this.fifthRoundTiles!.push(TileDto.fromJS(item));
            }
            if (Array.isArray(_data["sixthRoundTiles"])) {
                this.sixthRoundTiles = [] as any;
                for (let item of _data["sixthRoundTiles"])
                    this.sixthRoundTiles!.push(TileDto.fromJS(item));
            }
            if (Array.isArray(_data["players"])) {
                this.players = [] as any;
                for (let item of _data["players"])
                    this.players!.push(PlayerDto.fromJS(item));
            }
            if (Array.isArray(_data["turns"])) {
                this.turns = [] as any;
                for (let item of _data["turns"])
                    this.turns!.push(TurnDto.fromJS(item));
            }
        }
    }

    static override fromJS(data: any): GameDto {
        data = typeof data === 'object' ? data : {};
        let result = new GameDto();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["gameName"] = this.gameName;
        data["gameStatus"] = this.gameStatus;
        data["startingPlayerId"] = this.startingPlayerId;
        data["passTile"] = this.passTile ? this.passTile.toJSON() : <any>undefined;
        if (Array.isArray(this.firstRoundTiles)) {
            data["firstRoundTiles"] = [];
            for (let item of this.firstRoundTiles)
                data["firstRoundTiles"].push(item.toJSON());
        }
        if (Array.isArray(this.secondRoundTiles)) {
            data["secondRoundTiles"] = [];
            for (let item of this.secondRoundTiles)
                data["secondRoundTiles"].push(item.toJSON());
        }
        if (Array.isArray(this.thirdRoundTiles)) {
            data["thirdRoundTiles"] = [];
            for (let item of this.thirdRoundTiles)
                data["thirdRoundTiles"].push(item.toJSON());
        }
        if (Array.isArray(this.fourthRoundTiles)) {
            data["fourthRoundTiles"] = [];
            for (let item of this.fourthRoundTiles)
                data["fourthRoundTiles"].push(item.toJSON());
        }
        if (Array.isArray(this.fifthRoundTiles)) {
            data["fifthRoundTiles"] = [];
            for (let item of this.fifthRoundTiles)
                data["fifthRoundTiles"].push(item.toJSON());
        }
        if (Array.isArray(this.sixthRoundTiles)) {
            data["sixthRoundTiles"] = [];
            for (let item of this.sixthRoundTiles)
                data["sixthRoundTiles"].push(item.toJSON());
        }
        if (Array.isArray(this.players)) {
            data["players"] = [];
            for (let item of this.players)
                data["players"].push(item.toJSON());
        }
        if (Array.isArray(this.turns)) {
            data["turns"] = [];
            for (let item of this.turns)
                data["turns"].push(item.toJSON());
        }
        super.toJSON(data);
        return data;
    }
}

export interface IGameDto extends IBaseDtoOfGuid {
    gameName: string;
    gameStatus: GameStatus;
    startingPlayerId: string;
    passTile: TileDto;
    firstRoundTiles: TileDto[];
    secondRoundTiles: TileDto[];
    thirdRoundTiles: TileDto[];
    fourthRoundTiles: TileDto[];
    fifthRoundTiles: TileDto[];
    sixthRoundTiles: TileDto[];
    players: PlayerDto[];
    turns: TurnDto[];
}

export enum GameStatus {
    Setup = 0,
    InProgress = 1,
    Finished = 2,
}

export class TileDto extends BaseDtoOfGuid implements ITileDto {
    type!: TileType;
    shape!: TileShape;
    typePositionX!: number;
    typePositionY!: number;
    typeQuantity!: number;

    constructor(data?: ITileDto) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.type = _data["type"];
            this.shape = _data["shape"];
            this.typePositionX = _data["typePositionX"];
            this.typePositionY = _data["typePositionY"];
            this.typeQuantity = _data["typeQuantity"];
        }
    }

    static override fromJS(data: any): TileDto {
        data = typeof data === 'object' ? data : {};
        let result = new TileDto();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["type"] = this.type;
        data["shape"] = this.shape;
        data["typePositionX"] = this.typePositionX;
        data["typePositionY"] = this.typePositionY;
        data["typeQuantity"] = this.typeQuantity;
        super.toJSON(data);
        return data;
    }
}

export interface ITileDto extends IBaseDtoOfGuid {
    type: TileType;
    shape: TileShape;
    typePositionX: number;
    typePositionY: number;
    typeQuantity: number;
}

export enum TileType {
    MapleTree = 0,
    Pagoda = 1,
    Fish = 2,
    AzaleaBush = 3,
    Boxwood = 4,
    Stone = 5,
    Pass = 6,
}

export enum TileShape {
    Single = 0,
    Double = 1,
    Triple = 2,
    Corner = 3,
    Pass = 4,
}

export class PlayerDto extends BaseDtoOfGuid implements IPlayerDto {
    name!: string;
    gameId!: string;
    userId!: string;
    gameReady!: boolean;
    gameLeader!: boolean;
    gamePieceColor!: string;
    order?: number;

    constructor(data?: IPlayerDto) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.name = _data["name"];
            this.gameId = _data["gameId"];
            this.userId = _data["userId"];
            this.gameReady = _data["gameReady"];
            this.gameLeader = _data["gameLeader"];
            this.gamePieceColor = _data["gamePieceColor"];
            this.order = _data["order"];
        }
    }

    static override fromJS(data: any): PlayerDto {
        data = typeof data === 'object' ? data : {};
        let result = new PlayerDto();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["gameId"] = this.gameId;
        data["userId"] = this.userId;
        data["gameReady"] = this.gameReady;
        data["gameLeader"] = this.gameLeader;
        data["gamePieceColor"] = this.gamePieceColor;
        data["order"] = this.order;
        super.toJSON(data);
        return data;
    }
}

export interface IPlayerDto extends IBaseDtoOfGuid {
    name: string;
    gameId: string;
    userId: string;
    gameReady: boolean;
    gameLeader: boolean;
    gamePieceColor: string;
    order?: number;
}

export class TurnDto implements ITurnDto {
    round!: number;
    turnNumber!: number;
    playerId!: string;
    tileId!: string;
    positionX!: number;
    positionY!: number;
    rotation!: TileRotation;
    layer!: number;

    constructor(data?: ITurnDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.round = _data["round"];
            this.turnNumber = _data["turnNumber"];
            this.playerId = _data["playerId"];
            this.tileId = _data["tileId"];
            this.positionX = _data["positionX"];
            this.positionY = _data["positionY"];
            this.rotation = _data["rotation"];
            this.layer = _data["layer"];
        }
    }

    static fromJS(data: any): TurnDto {
        data = typeof data === 'object' ? data : {};
        let result = new TurnDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["round"] = this.round;
        data["turnNumber"] = this.turnNumber;
        data["playerId"] = this.playerId;
        data["tileId"] = this.tileId;
        data["positionX"] = this.positionX;
        data["positionY"] = this.positionY;
        data["rotation"] = this.rotation;
        data["layer"] = this.layer;
        return data;
    }
}

export interface ITurnDto {
    round: number;
    turnNumber: number;
    playerId: string;
    tileId: string;
    positionX: number;
    positionY: number;
    rotation: TileRotation;
    layer: number;
}

export enum TileRotation {
    Zero = 0,
    Ninety = 1,
    OneHundredEighty = 2,
    TwoHunderedSeventy = 3,
    Pass = 4,
}

export class ProblemDetails implements IProblemDetails {
    type?: string | undefined;
    title?: string | undefined;
    status?: number | undefined;
    detail?: string | undefined;
    instance?: string | undefined;

    [key: string]: any;

    constructor(data?: IProblemDetails) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.type = _data["type"];
            this.title = _data["title"];
            this.status = _data["status"];
            this.detail = _data["detail"];
            this.instance = _data["instance"];
        }
    }

    static fromJS(data: any): ProblemDetails {
        data = typeof data === 'object' ? data : {};
        let result = new ProblemDetails();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["type"] = this.type;
        data["title"] = this.title;
        data["status"] = this.status;
        data["detail"] = this.detail;
        data["instance"] = this.instance;
        return data;
    }
}

export interface IProblemDetails {
    type?: string | undefined;
    title?: string | undefined;
    status?: number | undefined;
    detail?: string | undefined;
    instance?: string | undefined;

    [key: string]: any;
}

export class HttpValidationProblemDetails extends ProblemDetails implements IHttpValidationProblemDetails {
    errors?: { [key: string]: string[]; };

    [key: string]: any;

    constructor(data?: IHttpValidationProblemDetails) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            if (_data["errors"]) {
                this.errors = {} as any;
                for (let key in _data["errors"]) {
                    if (_data["errors"].hasOwnProperty(key))
                        (<any>this.errors)![key] = _data["errors"][key] !== undefined ? _data["errors"][key] : [];
                }
            }
        }
    }

    static override fromJS(data: any): HttpValidationProblemDetails {
        data = typeof data === 'object' ? data : {};
        let result = new HttpValidationProblemDetails();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        if (this.errors) {
            data["errors"] = {};
            for (let key in this.errors) {
                if (this.errors.hasOwnProperty(key))
                    (<any>data["errors"])[key] = (<any>this.errors)[key];
            }
        }
        super.toJSON(data);
        return data;
    }
}

export interface IHttpValidationProblemDetails extends IProblemDetails {
    errors?: { [key: string]: string[]; };

    [key: string]: any;
}

export class ValidationProblemDetails extends HttpValidationProblemDetails implements IValidationProblemDetails {
    errors?: { [key: string]: string[]; };

    [key: string]: any;

    constructor(data?: IValidationProblemDetails) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            if (_data["errors"]) {
                this.errors = {} as any;
                for (let key in _data["errors"]) {
                    if (_data["errors"].hasOwnProperty(key))
                        (<any>this.errors)![key] = _data["errors"][key] !== undefined ? _data["errors"][key] : [];
                }
            }
        }
    }

    static override fromJS(data: any): ValidationProblemDetails {
        data = typeof data === 'object' ? data : {};
        let result = new ValidationProblemDetails();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        if (this.errors) {
            data["errors"] = {};
            for (let key in this.errors) {
                if (this.errors.hasOwnProperty(key))
                    (<any>data["errors"])[key] = (<any>this.errors)[key];
            }
        }
        super.toJSON(data);
        return data;
    }
}

export interface IValidationProblemDetails extends IHttpValidationProblemDetails {
    errors?: { [key: string]: string[]; };

    [key: string]: any;
}

export class CreateGameDto implements ICreateGameDto {
    gameName!: string;
    playerName!: string;
    userId!: string;
    connectionId?: string | undefined;

    constructor(data?: ICreateGameDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.gameName = _data["gameName"];
            this.playerName = _data["playerName"];
            this.userId = _data["userId"];
            this.connectionId = _data["connectionId"];
        }
    }

    static fromJS(data: any): CreateGameDto {
        data = typeof data === 'object' ? data : {};
        let result = new CreateGameDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["gameName"] = this.gameName;
        data["playerName"] = this.playerName;
        data["userId"] = this.userId;
        data["connectionId"] = this.connectionId;
        return data;
    }
}

export interface ICreateGameDto {
    gameName: string;
    playerName: string;
    userId: string;
    connectionId?: string | undefined;
}

export class UserDto extends BaseDtoOfGuid implements IUserDto {
    name!: string;
    players?: Player[];

    constructor(data?: IUserDto) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.name = _data["name"];
            if (Array.isArray(_data["players"])) {
                this.players = [] as any;
                for (let item of _data["players"])
                    this.players!.push(Player.fromJS(item));
            }
        }
    }

    static override fromJS(data: any): UserDto {
        data = typeof data === 'object' ? data : {};
        let result = new UserDto();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        if (Array.isArray(this.players)) {
            data["players"] = [];
            for (let item of this.players)
                data["players"].push(item.toJSON());
        }
        super.toJSON(data);
        return data;
    }
}

export interface IUserDto extends IBaseDtoOfGuid {
    name: string;
    players?: Player[];
}

export abstract class BaseModelOfGuid implements IBaseModelOfGuid {
    id?: string;

    constructor(data?: IBaseModelOfGuid) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): BaseModelOfGuid {
        data = typeof data === 'object' ? data : {};
        throw new Error("The abstract class 'BaseModelOfGuid' cannot be instantiated.");
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        return data;
    }
}

export interface IBaseModelOfGuid {
    id?: string;
}

export class Player extends BaseModelOfGuid implements IPlayer {
    name!: string;
    gameId?: string;
    game?: Game | undefined;
    userId?: string;
    user?: User | undefined;
    gameReady?: boolean;
    gameLeader?: boolean;
    gamePieceColor?: string | undefined;
    order?: number;

    constructor(data?: IPlayer) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.name = _data["name"];
            this.gameId = _data["gameId"];
            this.game = _data["game"] ? Game.fromJS(_data["game"]) : <any>undefined;
            this.userId = _data["userId"];
            this.user = _data["user"] ? User.fromJS(_data["user"]) : <any>undefined;
            this.gameReady = _data["gameReady"];
            this.gameLeader = _data["gameLeader"];
            this.gamePieceColor = _data["gamePieceColor"];
            this.order = _data["order"];
        }
    }

    static override fromJS(data: any): Player {
        data = typeof data === 'object' ? data : {};
        let result = new Player();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["gameId"] = this.gameId;
        data["game"] = this.game ? this.game.toJSON() : <any>undefined;
        data["userId"] = this.userId;
        data["user"] = this.user ? this.user.toJSON() : <any>undefined;
        data["gameReady"] = this.gameReady;
        data["gameLeader"] = this.gameLeader;
        data["gamePieceColor"] = this.gamePieceColor;
        data["order"] = this.order;
        super.toJSON(data);
        return data;
    }
}

export interface IPlayer extends IBaseModelOfGuid {
    name: string;
    gameId?: string;
    game?: Game | undefined;
    userId?: string;
    user?: User | undefined;
    gameReady?: boolean;
    gameLeader?: boolean;
    gamePieceColor?: string | undefined;
    order?: number;
}

export class Game extends BaseModelOfGuid implements IGame {
    gameName!: string;
    gameStatus!: GameStatus;
    startingPlayerId?: string;
    passTile?: Tile | undefined;
    firstRoundTiles?: Tile[] | undefined;
    secondRoundTiles?: Tile[] | undefined;
    thirdRoundTiles?: Tile[] | undefined;
    fourthRoundTiles?: Tile[] | undefined;
    fifthRoundTiles?: Tile[] | undefined;
    sixthRoundTiles?: Tile[] | undefined;
    turns?: Turn[] | undefined;
    players?: Player[] | undefined;

    constructor(data?: IGame) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.gameName = _data["gameName"];
            this.gameStatus = _data["gameStatus"];
            this.startingPlayerId = _data["startingPlayerId"];
            this.passTile = _data["passTile"] ? Tile.fromJS(_data["passTile"]) : <any>undefined;
            if (Array.isArray(_data["firstRoundTiles"])) {
                this.firstRoundTiles = [] as any;
                for (let item of _data["firstRoundTiles"])
                    this.firstRoundTiles!.push(Tile.fromJS(item));
            }
            if (Array.isArray(_data["secondRoundTiles"])) {
                this.secondRoundTiles = [] as any;
                for (let item of _data["secondRoundTiles"])
                    this.secondRoundTiles!.push(Tile.fromJS(item));
            }
            if (Array.isArray(_data["thirdRoundTiles"])) {
                this.thirdRoundTiles = [] as any;
                for (let item of _data["thirdRoundTiles"])
                    this.thirdRoundTiles!.push(Tile.fromJS(item));
            }
            if (Array.isArray(_data["fourthRoundTiles"])) {
                this.fourthRoundTiles = [] as any;
                for (let item of _data["fourthRoundTiles"])
                    this.fourthRoundTiles!.push(Tile.fromJS(item));
            }
            if (Array.isArray(_data["fifthRoundTiles"])) {
                this.fifthRoundTiles = [] as any;
                for (let item of _data["fifthRoundTiles"])
                    this.fifthRoundTiles!.push(Tile.fromJS(item));
            }
            if (Array.isArray(_data["sixthRoundTiles"])) {
                this.sixthRoundTiles = [] as any;
                for (let item of _data["sixthRoundTiles"])
                    this.sixthRoundTiles!.push(Tile.fromJS(item));
            }
            if (Array.isArray(_data["turns"])) {
                this.turns = [] as any;
                for (let item of _data["turns"])
                    this.turns!.push(Turn.fromJS(item));
            }
            if (Array.isArray(_data["players"])) {
                this.players = [] as any;
                for (let item of _data["players"])
                    this.players!.push(Player.fromJS(item));
            }
        }
    }

    static override fromJS(data: any): Game {
        data = typeof data === 'object' ? data : {};
        let result = new Game();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["gameName"] = this.gameName;
        data["gameStatus"] = this.gameStatus;
        data["startingPlayerId"] = this.startingPlayerId;
        data["passTile"] = this.passTile ? this.passTile.toJSON() : <any>undefined;
        if (Array.isArray(this.firstRoundTiles)) {
            data["firstRoundTiles"] = [];
            for (let item of this.firstRoundTiles)
                data["firstRoundTiles"].push(item.toJSON());
        }
        if (Array.isArray(this.secondRoundTiles)) {
            data["secondRoundTiles"] = [];
            for (let item of this.secondRoundTiles)
                data["secondRoundTiles"].push(item.toJSON());
        }
        if (Array.isArray(this.thirdRoundTiles)) {
            data["thirdRoundTiles"] = [];
            for (let item of this.thirdRoundTiles)
                data["thirdRoundTiles"].push(item.toJSON());
        }
        if (Array.isArray(this.fourthRoundTiles)) {
            data["fourthRoundTiles"] = [];
            for (let item of this.fourthRoundTiles)
                data["fourthRoundTiles"].push(item.toJSON());
        }
        if (Array.isArray(this.fifthRoundTiles)) {
            data["fifthRoundTiles"] = [];
            for (let item of this.fifthRoundTiles)
                data["fifthRoundTiles"].push(item.toJSON());
        }
        if (Array.isArray(this.sixthRoundTiles)) {
            data["sixthRoundTiles"] = [];
            for (let item of this.sixthRoundTiles)
                data["sixthRoundTiles"].push(item.toJSON());
        }
        if (Array.isArray(this.turns)) {
            data["turns"] = [];
            for (let item of this.turns)
                data["turns"].push(item.toJSON());
        }
        if (Array.isArray(this.players)) {
            data["players"] = [];
            for (let item of this.players)
                data["players"].push(item.toJSON());
        }
        super.toJSON(data);
        return data;
    }
}

export interface IGame extends IBaseModelOfGuid {
    gameName: string;
    gameStatus: GameStatus;
    startingPlayerId?: string;
    passTile?: Tile | undefined;
    firstRoundTiles?: Tile[] | undefined;
    secondRoundTiles?: Tile[] | undefined;
    thirdRoundTiles?: Tile[] | undefined;
    fourthRoundTiles?: Tile[] | undefined;
    fifthRoundTiles?: Tile[] | undefined;
    sixthRoundTiles?: Tile[] | undefined;
    turns?: Turn[] | undefined;
    players?: Player[] | undefined;
}

export class Tile extends BaseModelOfGuid implements ITile {
    type?: TileType;
    shape?: TileShape;
    typePositionX?: number;
    typePositionY?: number;
    typeQuantity?: number;

    constructor(data?: ITile) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.type = _data["type"];
            this.shape = _data["shape"];
            this.typePositionX = _data["typePositionX"];
            this.typePositionY = _data["typePositionY"];
            this.typeQuantity = _data["typeQuantity"];
        }
    }

    static override fromJS(data: any): Tile {
        data = typeof data === 'object' ? data : {};
        let result = new Tile();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["type"] = this.type;
        data["shape"] = this.shape;
        data["typePositionX"] = this.typePositionX;
        data["typePositionY"] = this.typePositionY;
        data["typeQuantity"] = this.typeQuantity;
        super.toJSON(data);
        return data;
    }
}

export interface ITile extends IBaseModelOfGuid {
    type?: TileType;
    shape?: TileShape;
    typePositionX?: number;
    typePositionY?: number;
    typeQuantity?: number;
}

export class Turn implements ITurn {
    round?: number;
    turnNumber?: number;
    playerId?: string;
    tileId?: string;
    positionX?: number;
    positionY?: number;
    rotation?: TileRotation;
    layer?: number;

    constructor(data?: ITurn) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.round = _data["round"];
            this.turnNumber = _data["turnNumber"];
            this.playerId = _data["playerId"];
            this.tileId = _data["tileId"];
            this.positionX = _data["positionX"];
            this.positionY = _data["positionY"];
            this.rotation = _data["rotation"];
            this.layer = _data["layer"];
        }
    }

    static fromJS(data: any): Turn {
        data = typeof data === 'object' ? data : {};
        let result = new Turn();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["round"] = this.round;
        data["turnNumber"] = this.turnNumber;
        data["playerId"] = this.playerId;
        data["tileId"] = this.tileId;
        data["positionX"] = this.positionX;
        data["positionY"] = this.positionY;
        data["rotation"] = this.rotation;
        data["layer"] = this.layer;
        return data;
    }
}

export interface ITurn {
    round?: number;
    turnNumber?: number;
    playerId?: string;
    tileId?: string;
    positionX?: number;
    positionY?: number;
    rotation?: TileRotation;
    layer?: number;
}

export class User extends BaseModelOfGuid implements IUser {
    name!: string;
    players?: Player[];

    constructor(data?: IUser) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.name = _data["name"];
            if (Array.isArray(_data["players"])) {
                this.players = [] as any;
                for (let item of _data["players"])
                    this.players!.push(Player.fromJS(item));
            }
        }
    }

    static override fromJS(data: any): User {
        data = typeof data === 'object' ? data : {};
        let result = new User();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        if (Array.isArray(this.players)) {
            data["players"] = [];
            for (let item of this.players)
                data["players"].push(item.toJSON());
        }
        super.toJSON(data);
        return data;
    }
}

export interface IUser extends IBaseModelOfGuid {
    name: string;
    players?: Player[];
}

export class UpdateGameDto implements IUpdateGameDto {
    id!: string;
    gameStatus!: GameStatus;
    playerName?: string | undefined;
    userId?: string | undefined;
    connectionId?: string | undefined;

    constructor(data?: IUpdateGameDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.gameStatus = _data["gameStatus"];
            this.playerName = _data["playerName"];
            this.userId = _data["userId"];
            this.connectionId = _data["connectionId"];
        }
    }

    static fromJS(data: any): UpdateGameDto {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateGameDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["gameStatus"] = this.gameStatus;
        data["playerName"] = this.playerName;
        data["userId"] = this.userId;
        data["connectionId"] = this.connectionId;
        return data;
    }
}

export interface IUpdateGameDto {
    id: string;
    gameStatus: GameStatus;
    playerName?: string | undefined;
    userId?: string | undefined;
    connectionId?: string | undefined;
}

export class UpdatePlayerDto implements IUpdatePlayerDto {
    id!: string;
    name!: string;
    gameId!: string;
    gameReady!: boolean;
    gamePieceColor!: string;

    constructor(data?: IUpdatePlayerDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            this.gameId = _data["gameId"];
            this.gameReady = _data["gameReady"];
            this.gamePieceColor = _data["gamePieceColor"];
        }
    }

    static fromJS(data: any): UpdatePlayerDto {
        data = typeof data === 'object' ? data : {};
        let result = new UpdatePlayerDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["gameId"] = this.gameId;
        data["gameReady"] = this.gameReady;
        data["gamePieceColor"] = this.gamePieceColor;
        return data;
    }
}

export interface IUpdatePlayerDto {
    id: string;
    name: string;
    gameId: string;
    gameReady: boolean;
    gamePieceColor: string;
}

export class ApiException extends Error {
    override message: string;
    status: number;
    response: string;
    headers: { [key: string]: any; };
    result: any;

    constructor(message: string, status: number, response: string, headers: { [key: string]: any; }, result: any) {
        super();

        this.message = message;
        this.status = status;
        this.response = response;
        this.headers = headers;
        this.result = result;
    }

    protected isApiException = true;

    static isApiException(obj: any): obj is ApiException {
        return obj.isApiException === true;
    }
}

function throwException(message: string, status: number, response: string, headers: { [key: string]: any; }, result?: any): any {
    if (result !== null && result !== undefined)
        throw result;
    else
        throw new ApiException(message, status, response, headers, null);
}